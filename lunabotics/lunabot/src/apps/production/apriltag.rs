use std::f64::consts::PI;
use std::sync::mpsc::{Receiver, Sender, RecvTimeoutError};
use std::time::{Duration, Instant};

use apriltag::{families::TagStandard41h12, DetectorBuilder, Family, Image, TagParams};
use apriltag_image::{image::ImageBuffer, ImageExt};
use apriltag_nalgebra::PoseExt;
use fxhash::FxHashMap;
use nalgebra::{Isometry3, Point3, UnitQuaternion, Vector3};
use serde::Deserialize;

#[derive(Deserialize, Clone, Copy)]
pub struct Apriltag {
    pub tag_position: Point3<f64>,
    forward_axis: Vector3<f64>,
    #[serde(default)]
    roll: f64,
    pub tag_width: f64,
}

impl Apriltag {
    pub fn get_quat(self) -> UnitQuaternion<f64> {
        // First rotation to face along the forward axis
        let rotation1 =
            UnitQuaternion::rotation_between(&Vector3::new(0.0, 0.0, -1.0), &self.forward_axis)
                .unwrap_or(UnitQuaternion::from_scaled_axis(Vector3::new(0.0, PI, 0.0)));

        let cross_axis = self.forward_axis.cross(&Vector3::new(0.0, 1.0, 0.0));
        let true_up = cross_axis.cross(&self.forward_axis);

        // Second rotation to rotate the up axis to face directly up
        let actual_up = rotation1 * Vector3::new(0.0, 1.0, 0.0);
        let rotation2 = UnitQuaternion::rotation_between(&actual_up, &true_up).unwrap();

        // Third rotation to roll the tag
        let rotation3 = UnitQuaternion::from_scaled_axis(self.forward_axis.normalize() * self.roll);

        rotation3 * rotation2 * rotation1
    }
}

// Legacy code from urobotics-apriltag
pub use apriltag_image::image;
use tracing::{error, warn};

/// An observation of the global orientation and position
/// of the camera that observed an apriltag.
#[derive(Clone, Copy)]
pub struct TagObservation {
    /// The orientation and position of the apriltag relative to the observer.
    pub tag_local_isometry: Isometry3<f64>,
    /// The orientation and position of the apriltag in global space.
    ///
    /// These are the same values that were passed to `add_tag`. As such,
    /// if these values were not known then, this value will be incorrect.
    /// However, this can be set to the correct value, allowing
    /// `get_isometry_of_observer` to produce correct results.
    pub tag_global_isometry: Isometry3<f64>,
    /// The goodness of an observation.
    ///
    /// This is a value generated by the apriltag detector.
    pub decision_margin: f32,

    pub tag_id: usize,
}

impl std::fmt::Debug for TagObservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("PoseObservation")
            .field("pose", &self.tag_local_isometry)
            .field("decision_margin", &self.decision_margin)
            .finish()
    }
}

impl TagObservation {
    /// Get the isometry of the observer.
    pub fn get_isometry_of_observer(&self) -> Isometry3<f64> {
        // let mut observer_pose = self.tag_local_isometry;
        // observer_pose.translation.vector = self.tag_global_isometry.translation.vector
        //     + self.tag_global_isometry.rotation
        //         * observer_pose.rotation.inverse()
        //         * observer_pose.translation.vector;
        // observer_pose.rotation = self.tag_global_isometry.rotation
        //     * UnitQuaternion::from_axis_angle(&(observer_pose.rotation * Vector3::y_axis()), PI)
        //     * observer_pose.rotation;
        // observer_pose
        let inv_rotation = self.tag_local_isometry.rotation.inverse();
        self.tag_global_isometry
            * Isometry3::from_parts(
                (inv_rotation * -self.tag_local_isometry.translation.vector).into(),
                inv_rotation,
            )
    }
}

struct KnownTag {
    pose: Isometry3<f64>,
    tag_params: TagParams,
}

/// A Node that can detect apriltags in images.
///
/// Actual detection does not occur until the node
/// is running.
pub struct AprilTagDetector {
    img_receiver: Receiver<ImageBuffer<image::Luma<u8>, Vec<u8>>>,
    detection_sender: Sender<TagObservation>,
    known_tags: FxHashMap<usize, KnownTag>,
    pub focal_length_x_px: f64,
    pub focal_length_y_px: f64,
    pub image_width: u32,
    pub image_height: u32,
}

impl AprilTagDetector {
    /// Creates a new detector for a specific camera.
    ///
    /// The given `image_receiver` must produce images that
    /// have a width of `image_width` and a height of
    /// `image_height`, and the camera that produced it
    /// must have a focal length, in pixels, of `focal_length_px`.
    pub fn new(
        focal_length_x_px: f64,
        focal_length_y_px: f64,
        image_width: u32,
        image_height: u32,
        img_receiver: Receiver<ImageBuffer<image::Luma<u8>, Vec<u8>>>,
        detection_sender: Sender<TagObservation>,
    ) -> Self {
        Self {
            img_receiver,
            detection_sender,
            known_tags: Default::default(),
            focal_length_x_px,
            focal_length_y_px,
            image_width,
            image_height,
        }
    }

    /// Add a 41h12 tag to look out for. All units are in meters.
    ///
    /// Orientations and positions should be in global space. If this
    /// is not known, any value can be used. However, [`TagObservation::get_isometry_of_observer`]
    /// will not produce correct results in that case.
    pub fn add_tag(
        &mut self,
        tag_position: Point3<f64>,
        tag_orientation: UnitQuaternion<f64>,
        tag_width: f64,
        tag_id: usize,
    ) {
        self.known_tags.insert(
            tag_id,
            KnownTag {
                pose: Isometry3::from_parts(tag_position.into(), tag_orientation),
                tag_params: TagParams {
                    tagsize: tag_width,
                    fx: self.focal_length_x_px,
                    fy: self.focal_length_y_px,
                    cx: self.image_width as f64 / 2.0,
                    cy: self.image_height as f64 / 2.0,
                },
            },
        );
    }
}

impl AprilTagDetector {
    pub fn run(self) {
        let mut detector = DetectorBuilder::new()
            .add_family_bits(TagStandard41h12::default(), 1)
            .add_family_bits(Family::Tag36h11(Default::default()), 1)
            .build()
            .unwrap();

        tracing::info!("AprilTag detector started");
        let mut frame_count = 0;
        let start_time = Instant::now();

        loop {
            tracing::info!("Waiting for image...");
            let recv_start = Instant::now();
            
            // Use a timeout to avoid blocking indefinitely
            let img = match self.img_receiver.recv_timeout(Duration::from_secs(1)) {
                Ok(img) => {
                    let recv_duration = recv_start.elapsed();
                    tracing::info!("Received image from detector (took {:.3}ms)", recv_duration.as_secs_f64() * 1000.0);
                    img
                },
                Err(RecvTimeoutError::Timeout) => {
                    tracing::warn!("Timeout waiting for image - no image received for 1 second");
                    continue;
                },
                Err(RecvTimeoutError::Disconnected) => {
                    error!("Image channel closed, stopping detector");
                    break;
                }
            };
            
            frame_count += 1;
            if frame_count % 10 == 0 {
                let fps = frame_count as f64 / start_time.elapsed().as_secs_f64();
                tracing::info!("Processing {:.2} FPS ({} frames)", fps, frame_count);
            }
            
            if img.width() != self.image_width || img.height() != self.image_height {
                error!(
                    "Received incorrectly sized image: {}x{}",
                    img.width(),
                    img.height()
                );
                continue;
            }
            
            let processing_start = Instant::now();
            let img = Image::from_image_buffer(&img);
            tracing::info!("Image converted in {:.3}ms", processing_start.elapsed().as_secs_f64() * 1000.0);

            let detection_start = Instant::now();
            let detections = detector.detect(&img);
            let detection_time = detection_start.elapsed();
            
            tracing::info!("AprilTag detection took {:.3}ms, found {} tags", 
                         detection_time.as_secs_f64() * 1000.0,
                         detections.len());

            for detection in detections {
                if detection.decision_margin() < 130.0 {
                    tracing::info!("Tag {} decision margin: {}", detection.id(), detection.decision_margin());
                    continue;
                }
                tracing::info!("getting known tag");
                let Some(known) = self.known_tags.get(&detection.id()) else {
                    continue;
                };
                tracing::info!("got known tag");
                let pose_start = Instant::now();
                tracing::info!("estimating pose");
                let Some(tag_local_isometry) = detection.estimate_tag_pose(&known.tag_params)
                else {
                    warn!("Failed to estimate pose of {}", detection.id());
                    continue;
                };
                tracing::info!("got tag local isometry");
                
                // Create a direct conversion function instead of using to_na()
                fn apriltag_pose_to_nalgebra(pose: &apriltag::Pose) -> Isometry3<f64> {
                    let r: &[f64] = &pose.rotation().data();
                    let t: &[f64] = &pose.translation().data();
                    
                    tracing::info!("got pose rotation and translation");
                    // Extract rotation matrix values from flattened array (assuming column-major order)
                    let rot_matrix = nalgebra::Matrix3::new(
                        r[0], r[3], r[6],
                        r[1], r[4], r[7],
                        r[2], r[5], r[8],
                    );
                    
                    tracing::info!("made rotation matrix");
                    // Convert to UnitQuaternion
                    let rotation = if rot_matrix.is_special_orthogonal(1e-5) {
                        UnitQuaternion::from_matrix(&rot_matrix)
                    } else {
                        // Provide a fallback or log warning
                        tracing::warn!("Invalid rotation matrix detected");
                        UnitQuaternion::identity()
                    };
                    
                    tracing::info!("made the quat");
                    // Create translation vector
                    let translation = Vector3::new(t[0], t[1], t[2]);
                    
                    tracing::info!("made the translation");
                    // Create isometry from components
                    let iso = Isometry3::from_parts(translation.into(), rotation);

                    tracing::info!("made isometry from parts");

                    iso
                }
                
                // Convert directly without using to_na()
                let mut tag_local_isometry = apriltag_pose_to_nalgebra(&tag_local_isometry);
                tracing::info!("transformed tag local isometry");
                tag_local_isometry.translation.y *= -1.0;
                tag_local_isometry.translation.z *= -1.0;
                let mut scaled_axis = tag_local_isometry.rotation.scaled_axis();
                scaled_axis.y *= -1.0;
                scaled_axis.z *= -1.0;
                tracing::info!("scaled axis");
                tag_local_isometry.rotation = UnitQuaternion::from_scaled_axis(scaled_axis);
                tag_local_isometry.rotation = UnitQuaternion::from_scaled_axis(
                    tag_local_isometry.rotation * Vector3::new(0.0, PI, 0.0),
                ) * tag_local_isometry.rotation;
                
                tracing::info!("Pose estimation took {:.3}ms", pose_start.elapsed().as_secs_f64() * 1000.0);

                let send_start = Instant::now();
                match self.detection_sender.send(TagObservation {
                    tag_local_isometry,
                    decision_margin: detection.decision_margin(),
                    tag_global_isometry: known.pose,
                    tag_id: detection.id(),
                }) {
                    Ok(_) => {
                        tracing::info!("Sent detection (took {:.3}ms)", send_start.elapsed().as_secs_f64() * 1000.0);
                    },
                    Err(_) => {
                        error!("Detection channel closed, stopping detector");
                        break;
                    }
                }
            }
            
            let total_processing_time = processing_start.elapsed();
            tracing::info!("Total frame processing took {:.3}ms", total_processing_time.as_secs_f64() * 1000.0);
        }
    }
}
