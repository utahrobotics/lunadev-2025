use std::f64::consts::PI;

use apriltag::{families::TagStandard41h12, DetectorBuilder, Family, Image, TagParams};
use apriltag_image::{image::ImageBuffer, ImageExt};
use apriltag_nalgebra::PoseExt;
use fxhash::FxHashMap;
use nalgebra::{Isometry3, Point3, UnitQuaternion, Vector3};
use serde::Deserialize;

#[derive(Deserialize, Clone, Copy)]
pub struct Apriltag {
    pub tag_position: Point3<f64>,
    forward_axis: Vector3<f64>,
    #[serde(default)]
    roll: f64,
    pub tag_width: f64,
}

impl Apriltag {
    pub fn get_quat(self) -> UnitQuaternion<f64> {
        // First rotation to face along the forward axis
        let rotation1 =
            UnitQuaternion::rotation_between(&Vector3::new(0.0, 0.0, -1.0), &self.forward_axis)
                .unwrap_or(UnitQuaternion::from_scaled_axis(Vector3::new(0.0, PI, 0.0)));

        let cross_axis = self.forward_axis.cross(&Vector3::new(0.0, 1.0, 0.0));
        let true_up = cross_axis.cross(&self.forward_axis);

        // Second rotation to rotate the up axis to face directly up
        let actual_up = rotation1 * Vector3::new(0.0, 1.0, 0.0);
        let rotation2 = UnitQuaternion::rotation_between(&actual_up, &true_up).unwrap();

        // Third rotation to roll the tag
        let rotation3 = UnitQuaternion::from_scaled_axis(self.forward_axis.normalize() * self.roll);

        rotation3 * rotation2 * rotation1
    }
}

// Legacy code from urobotics-apriltag
pub use apriltag_image::image;
use tasker::{define_callbacks, fn_alias, shared::SharedDataReceiver};
use tracing::{error, warn, info};

define_callbacks!(DetectionCallbacks => Fn(detection: TagObservation) + Send + Sync);
fn_alias! {
    pub type DetectionCallbacksRef = CallbacksRef(TagObservation) + Send + Sync
}

/// An observation of the global orientation and position
/// of the camera that observed an apriltag.
#[derive(Clone, Copy)]
pub struct TagObservation {
    /// The orientation and position of the apriltag relative to the observer.
    pub tag_local_isometry: Isometry3<f64>,
    /// The orientation and position of the apriltag in global space.
    ///
    /// These are the same values that were passed to `add_tag`. As such,
    /// if these values were not known then, this value will be incorrect.
    /// However, this can be set to the correct value, allowing
    /// `get_isometry_of_observer` to produce correct results.
    pub tag_global_isometry: Isometry3<f64>,
    /// The goodness of an observation.
    ///
    /// This is a value generated by the apriltag detector.
    pub decision_margin: f32,

    pub tag_id: usize,
}

impl std::fmt::Debug for TagObservation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("PoseObservation")
            .field("pose", &self.tag_local_isometry)
            .field("decision_margin", &self.decision_margin)
            .finish()
    }
}

impl TagObservation {
    /// Get the isometry of the observer.
    pub fn get_isometry_of_observer(&self) -> Isometry3<f64> {
        // let mut observer_pose = self.tag_local_isometry;
        // observer_pose.translation.vector = self.tag_global_isometry.translation.vector
        //     + self.tag_global_isometry.rotation
        //         * observer_pose.rotation.inverse()
        //         * observer_pose.translation.vector;
        // observer_pose.rotation = self.tag_global_isometry.rotation
        //     * UnitQuaternion::from_axis_angle(&(observer_pose.rotation * Vector3::y_axis()), PI)
        //     * observer_pose.rotation;
        // observer_pose
        let inv_rotation = self.tag_local_isometry.rotation.inverse();
        self.tag_global_isometry
            * Isometry3::from_parts(
                (inv_rotation * -self.tag_local_isometry.translation.vector).into(),
                inv_rotation,
            )
    }
}

struct KnownTag {
    pose: Isometry3<f64>,
    tag_params: TagParams,
}

/// A Node that can detect apriltags in images.
///
/// Actual detection does not occur until the node
/// is running.
pub struct AprilTagDetector {
    img_subscriber: SharedDataReceiver<ImageBuffer<image::Luma<u8>, Vec<u8>>>,
    detection_callbacks: DetectionCallbacks,
    known_tags: FxHashMap<usize, KnownTag>,
    pub focal_length_x_px: f64,
    pub focal_length_y_px: f64,
    pub image_width: u32,
    pub image_height: u32,
}

impl AprilTagDetector {
    /// Creates a new detector for a specific camera.
    ///
    /// The given `image_sub` must produce images that
    /// have a width of `image_width` and a height of
    /// `image_height`, and the camera that produced it
    /// must have a focal length, in pixels, of `focal_length_px`.
    ///
    /// As such, it is strongly encouraged that the subscription
    /// should not be a sum of multiple subscriptions.
    pub fn new(
        focal_length_x_px: f64,
        focal_length_y_px: f64,
        image_width: u32,
        image_height: u32,
        img_subscriber: SharedDataReceiver<ImageBuffer<image::Luma<u8>, Vec<u8>>>,
    ) -> Self {
        Self {
            img_subscriber,
            detection_callbacks: DetectionCallbacks::default(),
            known_tags: Default::default(),
            focal_length_x_px,
            focal_length_y_px,
            image_width,
            image_height,
        }
    }

    /// Add a 41h12 tag to look out for. All units are in meters.
    ///
    /// Orientations and positions should be in global space. If this
    /// is not known, any value can be used. However, [`TagObservation::get_isometry_of_observer`]
    /// will not produce correct results in that case.
    pub fn add_tag(
        &mut self,
        tag_position: Point3<f64>,
        tag_orientation: UnitQuaternion<f64>,
        tag_width: f64,
        tag_id: usize,
    ) {
        self.known_tags.insert(
            tag_id,
            KnownTag {
                pose: Isometry3::from_parts(tag_position.into(), tag_orientation),
                tag_params: TagParams {
                    tagsize: tag_width,
                    fx: self.focal_length_x_px,
                    fy: self.focal_length_y_px,
                    cx: self.image_width as f64 / 2.0,
                    cy: self.image_height as f64 / 2.0,
                },
            },
        );
    }

    pub fn detection_callbacks_ref(&self) -> DetectionCallbacksRef {
        self.detection_callbacks.get_ref()
    }
}

impl AprilTagDetector {
    pub fn run(mut self) {
        let mut detector = DetectorBuilder::new()
            .add_family_bits(TagStandard41h12::default(), 1)
            .add_family_bits(Family::Tag36h11(Default::default()), 1)
            .build()
            .unwrap();

        loop {
            let img = self.img_subscriber.get();
            if img.width() != self.image_width || img.height() != self.image_height {
                error!(
                    "Received incorrectly sized image: {}x{}",
                    img.width(),
                    img.height()
                );
                continue;
            }
            let img = Image::from_image_buffer(&img);

            for detection in detector.detect(&img) {
                if detection.decision_margin() < 130.0 {
                    continue;
                }
                let Some(known) = self.known_tags.get(&detection.id()) else {
                    continue;
                };
                let mut tag_local_isometry = match simple_tag_pose_estimation(&detection, &known.tag_params) {
                    Some(iso) => iso,
                    None => {
                        warn!("Failed to estimate pose of {}", detection.id());
                        continue;
                    }
                };

                // Now it's mutable so we can modify it
                tag_local_isometry.translation.y *= -1.0;
                tag_local_isometry.translation.z *= -1.0;

                // Print result to verify
                info!("Simple pose estimation: trans={:?}, rot={:?}", 
                       tag_local_isometry.translation, tag_local_isometry.rotation);

                self.detection_callbacks.call(TagObservation {
                    tag_local_isometry,
                    decision_margin: detection.decision_margin(),
                    tag_global_isometry: known.pose,
                    tag_id: detection.id(),
                });
            }
        }
    }
}

fn simple_tag_pose_estimation(
    detection: &apriltag::Detection,
    params: &TagParams,
) -> Option<Isometry3<f64>> {
    // Get tag corners in image coordinates
    let corners = detection.corners();
    if corners.len() != 4 {
        return None;
    }

    // Calculate the center of the tag in image coordinates
    let img_center_x = corners.iter().map(|c| c[0]).sum::<f64>() / 4.0;
    let img_center_y = corners.iter().map(|c| c[1]).sum::<f64>() / 4.0;
    
    // Estimate the scale of the tag in the image
    let diag1 = ((corners[0][0] - corners[2][0]).powi(2) + (corners[0][1] - corners[2][1]).powi(2)).sqrt();
    let diag2 = ((corners[1][0] - corners[3][0]).powi(2) + (corners[1][1] - corners[3][1]).powi(2)).sqrt();
    let avg_diag = (diag1 + diag2) / 2.0;
    
    // Estimate depth based on tag size and focal length
    let depth = params.fx * params.tagsize / avg_diag;
    
    // Calculate x and y positions based on image center offset
    let x = (img_center_x - params.cx) * depth / params.fx;
    let y = (img_center_y - params.cy) * depth / params.fy;
    
    // Create translation vector
    let translation = Vector3::new(x, y, depth);
    
    // Simple rotation estimation - assume tag is roughly facing the camera
    // This is a basic approximation
    let rotation = UnitQuaternion::identity();
    
    Some(Isometry3::from_parts(translation.into(), rotation))
}
